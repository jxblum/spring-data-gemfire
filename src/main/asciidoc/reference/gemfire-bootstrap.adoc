[[gemfire-bootstrap]]
= Bootstrapping a Spring ApplicationContext in Pivotal GemFire

Normally, a Spring based application <<bootstrap,bootstraps Pivotal GemFire>> by using Spring Data for Pivotal GemFire's caching features.
By specifying a `<gfe:cache/>` element that uses the Spring Data for Pivotal GemFire XML namespace, a single embedded Pivotal GemFire
peer `Cache` instance is created and initialized with default settings in the same JVM process as your application.

However, it is sometimes necessary (perhaps as a requirement imposed by your IT organization) that Pivotal GemFire be fully managed
and operated by the provided Pivotal GemFire tool suite, perhaps with
http://geode.apache.org/docs/guide/11/tools_modules/gfsh/chapter_overview.html[Gfsh]. By using Gfsh,
Pivotal GemFire bootstraps your Spring application context rather than the other way around. Instead of
an application server or a Java main class that uses Spring Boot, Pivotal GemFire does the bootstrapping and
hosts your application.

NOTE: Pivotal GemFire is not an application server. In addition, there are limitations to using
this approach where the Pivotal GemFire cache configuration is concerned.

[[gemfire-bootstrap-gfsh]]
== Using Pivotal GemFire to Bootstrap a Spring Context Started with Gfsh

In order to bootstrap a Spring application context in Pivotal GemFire when starting a Pivotal GemFire Server process by using Gfsh,
you must use Pivotal GemFire's
http://geode.apache.org/docs/guide/11/basic_config/the_cache/setting_cache_initializer.html[initalizer].
An initializer block can declare a callback application that is launched after the cache is initialized by Pivotal GemFire.

An initializer is declared within an
http://geode.apache.org/docs/guide/11/reference/topics/cache_xml.html#initializer[initializer] element by
using a minimal snippet of Pivotal GemFire's native `cache.xml`. To bootstrap the Spring application context,
the `cache.xml` file is required, in much the same way as a minimal snippet of Spring XML config is needed to bootstrap
a Spring application context configured with component scanning (for example `<context:component-scan base-packages="..."/>`).

Fortunately, such an initializer is already conveniently provided by the framework: the
http://docs.spring.io/spring-data-gemfire/docs/current/api/org/springframework/data/gemfire/support/SpringContextBootstrappingInitializer.html[`SpringContextBootstrappingInitializer`].
The following example shows a typical yet minimal configuration for this class inside Pivotal GemFires's `cache.xml` file:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<cache xmlns="http://geode.apache.org/schema/cache"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://geode.apache.org/schema/cache http://geode.apache.org/schema/cache/cache-1.0.xsd"
       version="1.0">

  <initializer>
    <class-name>org.springframework.data.gemfire.support.SpringContextBootstrappingInitializer</class-name>
    <parameter name="contextConfigLocations">
      <string>classpath:application-context.xml</string>
    </parameter>
  </initializer>

</cache>
----

The `SpringContextBootstrappingInitializer` class follows conventions similar to Spring's `ContextLoaderListener`
class, which is used to bootstrap a Spring application context inside a web application, where application context
configuration files are specified with the `contextConfigLocations` servlet context parameter.

In addition, the `SpringContextBootstrappingInitializer` class can also be used with a `basePackages` parameter
to specify a comma-separated list of base packages that contain appropriately annotated application components.
The Spring container searches these components to find and create Spring beans and other application components
on the classpath, as the following example shows:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<cache xmlns="http://geode.apache.org/schema/cache"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://geode.apache.org/schema/cache http://geode.apache.org/schema/cache/cache-1.0.xsd"
       version="1.0">

  <initializer>
    <class-name>org.springframework.data.gemfire.support.SpringContextBootstrappingInitializer</class-name>
    <parameter name="basePackages">
      <string>org.mycompany.myapp.services,org.mycompany.myapp.dao,...</string>
    </parameter>
  </initializer>

</cache>
----

Then, with a properly configured and constructed `CLASSPATH` and `cache.xml` file (shown earlier) specified as
a command-line option when starting a Pivotal GemFire Server in Gfsh, the command-line would be as follows:

[source]
----
gfsh>start server --name=Server1 --log-level=config ...
    --classpath="/path/to/application/classes.jar:/path/to/spring-data-geode-<major>.<minor>.<maint>.RELEASE.jar"
    --cache-xml-file="/path/to/geode/cache.xml"
----

The `application-context.xml` can be any valid Spring context configuration metadata, including all of the SDG namespace
elements. The only limitation with this approach is that a Pivotal GemFire cache cannot be configured by using
the Spring Data for Pivotal GemFire namespace. In other words, none of the `<gfe:cache/>` element attributes
(such as `cache-xml-location`, `properties-ref`, `critical-heap-percentage`, `pdx-serializer-ref`, `lock-lease`, and others)
can be specified. If used, these attributes are ignored.

The reason for this is that Pivotal GemFire itself has already created and initialized the cache before the initializer
gets invoked. As a result, the cache already exists and, since it is a "`singleton`", it cannot be re-initialized
or have any of its configuration augmented.

[[gemfire-bootstrap-lazywiring]]
== Lazy-wiring Pivotal GemFire Components

Spring Data for Pivotal GemFire already provides support for wiring Pivotal GemFire components (such as `CacheListeners`,
`CacheLoaders`, `CacheWriters` and so on) that are declared and created by Pivotal GemFire in `cache.xml` by using
SDG's `WiringDeclarableSupport` class, as described in <<apis:declarable:autowiring>>. However, this works only
when Spring is the one doing the bootstrapping (that is, when Spring bootstraps Pivotal GemFire).

When your Spring application context is bootstrapped by Pivotal GemFire, these Pivotal GemFire application components go unnoticed,
because the Spring application context does not yet exist. The Spring application context does not get created
until Pivotal GemFire calls the initializer block, which only occurs after all the other Pivotal GemFire components and configuration
have already been created and initialized.

To solve this problem, a new `LazyWiringDeclarableSupport` class was introduced. This new class is aware of the
Spring application context. The intention of this abstract base class is that any implementing class
register itself to be configured by the Spring container that is eventually be created by Pivotal GemFire
once the initializer is called. In essence, this gives your Pivotal GemFire application components a chance
to be configured and auto-wired with Spring beans defined in the Spring application context.

In order for your Pivotal GemFire application components to be auto-wired by the Spring container, you should create an application class
that extends the `LazyWiringDeclarableSupport` and annotate any class member that needs to be provided as
a Spring bean dependency, similar to the following example:

[source,java]
----
public class UserDataSourceCacheLoader extends LazyWiringDeclarableSupport
    implements CacheLoader<String, User> {

  @Autowired
  private DataSource userDataSource;

  ...
}
----

As implied in the `CacheLoader` example above, you might necessarily (though rarely) have defined both
a region and a `CacheListener` component in Pivotal GemFire `cache.xml`. The `CacheLoader` may need access to an application DAO
(or perhaps a JDBC `DataSource` defined in the Spring application context) for loading `Users` into a Pivotal GemFire `REPLICATE` region
on start.

CAUTION
====
Be careful when mixing the different life-cycles of Pivotal GemFire and the Spring Container together
in this manner. Not all use cases and scenarios are supported. The Pivotal GemFire `cache.xml` configuration would be
similar to the following (which comes from SDG's test suite):

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<cache xmlns="http://geode.apache.org/schema/cache"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://geode.apache.org/schema/cache http://geode.apache.org/schema/cache/cache-1.0.xsd"
       version="1.0">

  <region name="Users" refid="REPLICATE">
    <region-attributes initial-capacity="101" load-factor="0.85">
      <key-constraint>java.lang.String</key-constraint>
      <value-constraint>org.springframework.data.gemfire.repository.sample.User</value-constraint>
      <cache-loader>
        <class-name>
          org.springframework.data.gemfire.support.SpringContextBootstrappingInitializerIntegrationTest$UserDataStoreCacheLoader
        </class-name>
      </cache-loader>
    </region-attributes>
  </region>

  <initializer>
    <class-name>org.springframework.data.gemfire.support.SpringContextBootstrappingInitializer</class-name>
    <parameter name="basePackages">
      <string>org.springframework.data.gemfire.support.sample</string>
    </parameter>
  </initializer>

</cache>
----
====
