[[bootstrap:cache]]
= Configuring a Cache

To use Pivotal GemFire, you need to either create a new `Cache` or connect to an existing one.
With the current version of Pivotal GemFire, you can have only one open Cache per VM (more strictly, per `ClassLoader`).
In most cases, the `Cache` should only be created once.

NOTE: This section describes the creation and configuration of a peer cache member, appropriate in
peer-to-peer (P2P) topologies and cache servers. A cache member can also be used in stand-alone applications
and integration tests. However, in most typical production systems, most application processes act as
cache clients, creating a `ClientCache` instance instead. This is described in the <<bootstrap:cache:client>>
and <<bootstrap:region:client>> sections.

A peer cache with default configuration can be created with the following simple declaration:

[source,xml]
----
<gfe:cache/>
----

During Spring container initialization, any application context containing this cache definition registers
a `CacheFactoryBean` that creates a Spring bean named `gemfireCache`, which references a Pivotal GemFire `Cache` instance.
This bean refers to either an existing cache or, if one does not already exist, a newly created one.  Since no
additional properties were specified, a newly created cache applies the default cache configuration.

All Spring Data for Pivotal GemFire components that depend on the cache respect this naming convention, so you need not
explicitly declare the cache dependency. If you prefer, you can make the dependency explicit by using the `cache-ref`
attribute provided by various SDG XML namespace elements.  Also, you can override the cache's bean name using
the `id` attribute, as follows:

[source,xml]
----
<gfe:cache id="myCache"/>
----

A Pivotal GemFire `Cache` can be fully configured using Spring. However, Pivotal GemFire's native XML configuration file, `cache.xml`,
is also supported.  For situations where the Pivotal GemFire cache needs to be configured natively, you can provide a reference
to the Pivotal GemFire XML configuration file by using the `cache-xml-location` attribute, as follows:

[source,xml]
----
<gfe:cache id="cacheConfiguredWithNativeXml" cache-xml-location="classpath:cache.xml"/>
----

In this example, if a cache needs to be created, it uses a file named `cache.xml` located in the classpath root
to configure it.

NOTE: The configuration makes use of Spring's http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#resources[`Resource`]
abstraction to locate the file. The `Resource` abstraction lets various search patterns be used, depending on the runtime environment
or the prefix specified (if any) in the resource location.

In addition to referencing an external XML configuration file, you can also specify Pivotal GemFire System
http://geode.apache.org/docs/guide/11/reference/topics/gemfire_properties.html[properties]
that use any of Spring's `Properties` support features.

For example, you can use the `properties` element defined in the `util` namespace to define `Properties`
directly or load properties from a properties file, as follows:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:gfe="http://www.springframework.org/schema/gemfire"
  xmlns:util="http://www.springframework.org/schema/util"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="
    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/gemfire http://www.springframework.org/schema/gemfire/spring-gemfire.xsd
    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">

  <util:properties id="gemfireProperties" location="file:/path/to/gemfire.properties"/>

  <gfe:cache properties-ref="gemfireProperties"/>

</beans>
----

Using a properties file is recommended for externalizing environment-specific settings outside
the application configuration.

NOTE: Cache settings apply only when a new cache needs to be created. If an open cache already exists in the VM,
these settings are ignored.

[[bootstrap:cache:advanced]]
== Advanced Cache Configuration

For advanced cache configuration, the `cache` element provides a number of configuration options exposed as attributes
or child elements, as the following listing shows:

[source,xml]
----
<!--1-->
<gfe:cache
    cache-xml-location=".."
    properties-ref=".."
    close="false"
    copy-on-read="true"
    critical-heap-percentage="90"
    eviction-heap-percentage="70"
    enable-auto-reconnect="false" <!--2-->
    lock-lease="120"
    lock-timeout="60"
    message-sync-interval="1"
    pdx-serializer-ref="myPdxSerializer"
    pdx-persistent="true"
    pdx-disk-store="diskStore"
    pdx-read-serialized="false"
    pdx-ignore-unread-fields="true"
    search-timeout="300"
    use-bean-factory-locator="true" <!--3-->
    use-cluster-configuration="false" <!--4-->
>

  <gfe:transaction-listener ref="myTransactionListener"/> <!--5-->

  <gfe:transaction-writer> <!--6-->
    <bean class="org.example.app.gemfire.transaction.TransactionWriter"/>
  </gfe:transaction-writer>

  <gfe:gateway-conflict-resolver ref="myGatewayConflictResolver"/> <!--7-->

  <gfe:dynamic-region-factory/> <!--8-->

  <gfe:jndi-binding jndi-name="myDataSource" type="ManagedDataSource"/> <!--9-->

</gfe:cache>
----

<1> Attributes support various cache options. For further information regarding anything shown in this example,
see the Pivotal GemFire http://docs.pivotal.io/gemfire[product documentation].
The `close` attribute determines whether the cache should be closed when the Spring application context is closed.
The default is `true`. However, for use cases in which multiple application contexts use the cache
(common in web applications), set this value to `false`.
<2> Setting the `enable-auto-reconnect` attribute to `true` (the default is `false`) lets a disconnected Pivotal GemFire member
automatically reconnect and rejoin the Pivotal GemFire cluster.
See the Pivotal GemFire http://geode.apache.org/docs/guide/11/managing/autoreconnect/member-reconnect.html[product documentation]
for more details.
<3> Setting the `use-bean-factory-locator` attribute to `true` (it defaults to `false`) applies only when both
Spring (XML) configuration metadata and Pivotal GemFire `cache.xml` is used to configure the Pivotal GemFire cache node
(whether client or peer). This option lets Pivotal GemFire components (such as `CacheLoader`) expressed in `cache.xml`
be auto-wired with beans (such as `DataSource`) defined in the Spring application context. This option is typically
used in conjunction with `cache-xml-location`.
<4> Setting the `use-cluster-configuration` attribute to `true` (the default is `false`) enables a Pivotal GemFire member to
retrieve the common, shared Cluster-based configuration from a Locator.
See the Pivotal GemFire http://geode.apache.org/docs/guide/11/configuring/cluster_config/gfsh_persist.html[product documentation]
for more details.
<5> Example of a `TransactionListener` callback declaration that uses a bean reference. The referenced bean must implement
http://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/TransactionListener.html[TransactionListener].
A `TransactionListener` can be implemented to handle transaction related events (such as afterCommit and afterRollback).
<6> Example of a `TransactionWriter` callback declaration using an inner bean declaration. The bean must implement
http://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/TransactionWriter.html[TransactionWriter].
The `TransactionWriter` is a callback that can veto a transaction.
<7> Example of a `GatewayConflictResolver` callback declaration using a bean reference. The referenced bean
must implement http://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/util/GatewayConflictResolver.html
[GatewayConflictResolver].
A `GatewayConflictResolver` is a cache-level plugin that is called upon to decide what to do with events that originate
in other systems and arrive through the WAN Gateway.
<8> Enables Pivotal GemFire's http://geode.apache.org/docs/guide/11/developing/region_options/dynamic_region_creation.html[DynamicRegionFactory],
which provides a distributed Region creation service.
<9> Declares a JNDI binding to enlist an external DataSource in a Pivotal GemFire transaction.

[[bootstrap:cache:pdx-serialization]]
=== Enabling PDX Serialization

The preceding example includes a number of attributes related to Pivotal GemFire's enhanced serialization framework, PDX.
While a complete discussion of PDX is beyond the scope of this reference guide, it is important to note that PDX
is enabled by registering a `PdxSerializer`, which is specified by setting the `pdx-serializer` attribute. Pivotal GemFire provides
an implementing class (`org.apache.geode.pdx.ReflectionBasedAutoSerializer`) that uses Java Reflection. However, it is
common for developers to provide their own implementation. The value of the attribute is simply a reference to
a Spring bean that implements the `PdxSerializer` interface.

More information on serialization support can be found in <<serialization>>

[[boostrap:cache:auto-reconnect]]
=== Enabling Auto-reconnect

You should be careful when setting the `<gfe:cache enable-auto-reconnect="[true|false*]>` attribute to `true`.

Generally, 'auto-reconnect' should only be enabled in cases where Spring Data for Pivotal GemFire's XML namespace is used to
configure and bootstrap a new, non-application Pivotal GemFire Server to add to a cluster.  In other words, 'auto-reconnect'
should not be enabled when Spring Data for Pivotal GemFire is used to develop and build a Pivotal GemFire application that also happens
to be a peer cache member of the Pivotal GemFire cluster.

The main reason for this restriction is that most Pivotal GemFire applications use references to the Pivotal GemFire cache or Regions in order to
perform data access operations.  These references are "`injected`" by the Spring container into application components
(such as DAOs or Repositories) for use by the application. When a peer member is forcefully disconnected from the rest
of the cluster, presumably because the peer member has become unresponsive or a network partition separates one or more
peer members into a group too small to function as an independent distributed system, the peer member shuts down
and all Pivotal GemFire component references (caches, regions, and others) become invalid.

Essentially, the current forced-disconnect processing logic in each peer member dismantles the system from the ground up.
The JGroups stack shuts down, the distributed system is put in a shutdown state and, finally, the cache is closed.
Effectively, all memory references become stale and are lost.

After being disconnected from the distributed system, a peer member enters a "`reconnecting`" state and periodically
attempts to rejoin the distributed system. If the peer member succeeds in reconnecting, the member rebuilds
its "`view`" of the distributed system from existing members and receives a new distributed system ID.  Additionally, all
caches, regions, and other Pivotal GemFire components are reconstructed. Therefore, all old references, which may have been
injected into application by the Spring container, are now stale and no longer valid.

Pivotal GemFire makes no guarantee (even when using the Pivotal GemFire public Java API) that application cache, region, or other
component references are automatically refreshed by the reconnect operation. As such, Pivotal GemFire applications
must take care to refresh their own references.

Unfortunately, there is no way to be notified of a disconnect event and, subsequently, a reconnect event.
If that were the case, you would have a clean way to know when to call
`ConfigurableApplicationContext.refresh()`, if it were even applicable for an application to do so, which is why
this "`feature`" of Pivotal GemFire is not recommended for peer cache Pivotal GemFire applications.

For more information about 'auto-reconnect', see Pivotal GemFire's
http://geode.apache.org/docs/guide/11/managing/autoreconnect/member-reconnect.html[product documentation].

[[bootstrap:cache:cluster-configuration]]
=== Using Cluster-based Configuration

Pivotal GemFire's Cluster Configuration Service is a convenient way for any peer member joining the cluster to get
a "`consistent view`" of the cluster by using the shared, persistent configuration maintained by a locator.
Using the cluster-based Configuration ensures the peer member's configuration is compatible with
the Pivotal GemFire Distributed System when the member joins.

This feature of Spring Data for Pivotal GemFire (setting the `use-cluster-configuration` attribute to `true`) works in the same way
as the `cache-xml-location` attribute, except the source of the Pivotal GemFire configuration meta-data comes from the network
through a locator, as opposed to a native `cache.xml` file residing in the local file system.

All Pivotal GemFire native configuration metadata, whether from `cache.xml` or from the Cluster Configuration Service,
gets applied before any Spring (XML) configuration metadata.  As a result, Spring's config serves to "`augment`" the
native Pivotal GemFire configuration metadata and would most likely be specific to the application.

Again, to enable this feature, specify the following in the Spring XML config:

[source,xml]
----
  <gfe:cache use-cluster-configuration="true"/>
----

NOTE: While certain Pivotal GemFire tools, such as `Gfsh`, have their actions "`recorded`" when schema-like changes are made
(for example, `gfsh>create region --name=Example --type=PARTITION`), Spring Data for Pivotal GemFire's configuration metadata
is not recorded. The same is true when using Pivotal GemFire's public Java API directly. It, too, is not recorded.

For more information on Pivotal GemFire's Cluster Configuration Service, see the
http://geode.apache.org/docs/guide/11/configuring/cluster_config/gfsh_persist.html[product documentation].

[[bootstrap:cache:server]]
== Configuring a Pivotal GemFire CacheServer

Spring Data for Pivotal GemFire includes dedicated support for configuring a
http://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/server/CacheServer.html[CacheServer],
allowing complete configuration through the Spring container, as the following example shows:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:context="http://www.springframework.org/schema/context"
  xmlns:gfe="http://www.springframework.org/schema/gemfire"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="
    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/gemfire http://www.springframework.org/schema/gemfire/spring-gemfire.xsd
">

  <gfe:cache/>

  <!-- Example depicting serveral Pivotal GemFire CacheServer configuration options -->
  <gfe:cache-server id="advanced-config" auto-startup="true"
       bind-address="localhost" host-name-for-clients="localhost" port="${gemfire.cache.server.port}"
       load-poll-interval="2000" max-connections="22" max-message-count="1000" max-threads="16"
       max-time-between-pings="30000" groups="test-server">

    <gfe:subscription-config eviction-type="ENTRY" capacity="1000" disk-store="file://${java.io.tmpdir}"/>

  </gfe:cache-server>

  <context:property-placeholder location="classpath:cache-server.properties"/>

</beans>
----

The preceding configuration shows the `cache-server` element and the many available options.

NOTE: Rather than hard-coding the port, this configuration uses Spring's
http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#xsd-config-body-schemas-context[context]
namespace to declare a `property-placeholder`. A
http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-placeholderconfigurer[property placeholder]
reads one or more properties files and then replaces property placeholders with values at runtime. Doing so lets administrators
change values without having to touch the main application configuration. Spring also provides
http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#expressions[SpEL]
and an http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-environment[environment abstraction]
to support externalization of environment-specific properties from the main codebase, easing deployment
across multiple machines.

NOTE: To avoid initialization problems, the `CacheServer` started by Spring Data for Pivotal GemFire starts *after*
the Spring container has been fully initialized. Doing so lets potential regions, listeners, writers or instantiators that are
defined declaratively be fully initialized and registered before the server starts accepting connections.
Keep this in mind when programmatically configuring these elements, as the server might start after your components
and thus not be seen by the clients connecting right away.

[[bootstrap:cache:client]]
== Configuring a Pivotal GemFire ClientCache

In addition to defining a Pivotal GemFire peer http://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/Cache.html[cache],
Spring Data for Pivotal GemFire also supports the definition of a Pivotal GemFire http://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/client/ClientCache.html[`ClientCache`]
in a Spring context.  A `ClientCache` definition is similar in configuration and use to
the Pivotal GemFire peer <<bootstrap:cache,cache>> and is supported by the `org.springframework.data.gemfire.client.ClientCacheFactoryBean`.

The simplest definition of a Pivotal GemFire cache client using default configuration follows:

[source,xml]
----
<beans>
  <gfe:client-cache/>
</beans>
----

`client-cache` supports many of the same options as the <<bootstrap:cache:advanced,cache>> element. However, as opposed
to a full-fledged peer cache member, a cache client connects to a remote cache server through a pool. By default,
a pool is created to connect to a server running on `localhost` and listening to port `40404`. The default pool is used
by all client regions unless the region is configured to use a specific pool.

Pools can be defined with the `pool` element.  This client-side pool can be used to configure connectivity directly to
a server for individual entities or for the entire cache through one or more locators.

For example, to customize the default pool used by the `client-cache`, the developer needs to define a Pool and wire it
to the cache definition, as the following example shows:

[source,xml]
----
<beans>
  <gfe:client-cache id="my-cache" pool-name="myPool"/>

  <gfe:pool id="myPool" subscription-enabled="true">
    <gfe:locator host="${gemfire.locator.host}" port="${gemfire.locator.port}"/>
  </gfe:pool>
</beans>
----

The `<client-cache>` element also has a `ready-for-events` attribute. If the attribute is set to `true`, the client cache
initialization includes a call to http://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/client/ClientCache.html#readyForEvents[`ClientCache.readyForEvents()`].

<<bootstrap:region:client>> covers client-side configuration in more detail.

[[bootstrap:cache:client:pool]]
=== Pivotal GemFire's DEFAULT Pool and Spring Data for Pivotal GemFire Pool Definitions

If a Pivotal GemFire `ClientCache` is local-only, then no Pool definition is required. For instance, you can define the following:

[source,xml]
----
<gfe:client-cache/>

<gfe:client-region id="Example" shortcut="LOCAL"/>
----

In this case, the `Example` Region is `LOCAL` and no data is distributed between the client and a server. Therefore,
no pool is necessary. This is true for any client-side, local-only region, as defined by the Pivotal GemFire's
http://geode.apache.org/releases/latest/javadoc/org/apache/geode/cache/client/ClientRegionShortcut.html[`ClientRegionShortcut`]
(all `LOCAL_*` shortcuts).

However, if a client Region is a (caching) proxy to a server-side Region, a pool is required. In that case, there are several
ways to define and use a Pool.

When a client cache, a pool, and a proxy-based region are all defined but not explicitly identified, Spring Data for Pivotal GemFire
resolves the references automatically, as the following example shows:

[source,xml]
----
<gfe:client-cache/>

<gfe:pool>
  <gfe:locator host="${geode.locator.host}" port="${geode.locator.port}"/>
</gfe:pool>

<gfe:client-region id="Example" shortcut="PROXY"/>
----

In the preceding example, the client cache is identified as `gemfireCache`, the Pool as `gemfirePool`, and the client region
as `Example`.  However, the client cache initializes Pivotal GemFire's `DEFAULT` pool from `gemfirePool`, and the client Region
uses the `gemfirePool` when distributing data between the client and the server.

Basically, Spring Data for Pivotal GemFire resolves the preceding configuration to the following:

[source,xml]
----
<gfe:client-cache id="gemfireCache" pool-name="gemfirePool"/>

<gfe:pool id="gemfirePool">
  <gfe:locator host="${geode.locator.host}" port="${geode.locator.port}"/>
</gfe:pool>

<gfe:client-region id="Example" cache-ref="gemfireCache" pool-name="gemfirePool" shortcut="PROXY"/>
----

Pivotal GemFire still creates a pool called `DEFAULT`. Spring Data for Pivotal GemFire causes the `DEFAULT` pool to be
initialized from the `gemfirePool`. Doing so is useful in situations where multiple pools are defined and client regions
are using separate Pools.

Consider the following:

[source,xml]
----
<gfe:client-cache pool-name="locatorPool"/>

<gfe:pool id="locatorPool">
  <gfe:locator host="${geode.locator.host}" port="${geode.locator.port}"/>
</gfe:pool>

<gfe:pool id="serverPool">
  <gfe:server host="${geode.server.host}" port="${geode.server.port}"/>
</gfe:pool>

<gfe:client-region id="Example" pool-name="serverPool" shortcut="PROXY"/>

<gfe:client-region id="AnotherExample" shortcut="CACHING_PROXY"/>

<gfe:client-region id="YetAnotherExample" shortcut="LOCAL"/>
----

In this setup, the Pivotal GemFire client cache's `DEFAULT` pool is initialized from `locatorPool`, as specified by the
`pool-name` attribute. There is no Spring Data for Pivotal GemFire-defined `gemfirePool`, since both pools were explicitly
identified (named) -- `locatorPool` and `serverPool`, respectively.

The `Example` region explicitly refers to and exclusively uses the `serverPool`. The `AnotherExample` region uses
Pivotal GemFire's `DEFAULT` pool, which was configured from the `locatorPool` based on the client cache bean definition's
`pool-name` attribute.

Finally, the `YetAnotherExample` egion does not use a Pool, because it is `LOCAL`.

NOTE: The `AnotherExample` region would first look for a pool bean named `gemfirePool`, but that would require
the definition of an anonymous Pool bean (that is, `<gfe:pool/>`) or a pool bean explicitly named `gemfirePool`
(for example, `<gfe:pool id="gemfirePool"/>`).

NOTE: If we either changed the name of `locatorPool` to `gemfirePool` or made the pool bean definition be anonymous, it would have the same effect as the preceding configuration.
